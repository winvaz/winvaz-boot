package com.icore.winvaz.javase.basic;


import org.junit.jupiter.api.Test;

/**
 * 抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力是后续的封装，继承，多态的基础。
 * 在面向对象的思维中，抽象分为归纳与演绎。
 * 归纳是从具体到本质，从个性到共性，将一类对象的共同特征进行归一化的逻辑思维过程。
 * 演绎是从本质到具体，从共性到个性，逐步形象化的过程。
 * 在归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎。
 * 演绎也是一种抽象思维，并非具象思维。
 * 演绎是在已有问题多个解决方案的基础上，正确地找到合适的饿使用场景。
 * Object类是任何类的默认父类，是对万事万物的抽象。
 * 是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。
 * 哲学的三大经典问题：我是谁，我从哪里来，我到哪里去。
 * 我是谁？getClass()说明本质上是谁，而toString()是当前的名片。
 * 我从哪里来？ Object()构造方法是生产对象的基本方式，clone()是繁殖对象的另一种方式
 * 我到哪里去？ finalize()是在对象销毁时触发的方法。
 */

/**
 * 通过abstract定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；
 * 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；
 * 如果不实现抽象方法，则该子类仍是一个抽象类；
 * 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。
 */
public class AbstractTest {

    @Test
    public void test() {
        // 面向抽象编程
        // 面向抽象编程的本质就是：
        // 上层代码只定义规范（例如：abstract class Animal）；
        // 不需要子类就可以实现业务逻辑（正常编译）；
        // 具体的业务逻辑由不同的子类实现，调用者并不关心。

        // 当我们定义了抽象类Animal，以及具体的Cat、Dog子类的时候，
        // 我们可以通过抽象类Animal类型去引用具体的子类的实例
        Animal cat = new Cat();
        Animal dog = new Dog();
        // 这种引用抽象类的好处在于，我们对其进行方法调用，并不关心Animal类型变量的具体子类型
        cat.sleep();
        cat.eat();
        dog.sleep();
    }
}

/**
 * 定义类的过程就是抽象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象。
 * 仅定义公共行为和特征。接口和抽象类的共同点是都不能被实例化。但可以定义引用变量指向实例对象。
 * <p>
 * 抽象类在被继承时提现的是is-a的关系。
 * 接口在被继承时提现的是can-do的关系。
 * 抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法，实体方法，属性变量。
 * 如果一个抽象类只有一个抽象方法，那么它就等同于一个接口
 * is-a关系需要符合里氏代换原则
 * can-do关系要符合接口隔离原则，实现类要有能力去实现并执行接口中定义的方法。
 * <p>
 * 抽象类是模板式设计，抽象类包含一组相对具体的特征，性格偏内向
 * 接口是契约式设计，接口是开放的，性格偏外向。
 * <p>
 * 抽象类
 * 如果一个类定义了方法，该方法没有具体的执行代码，这个方法就是抽象方法，抽象方法用Abstract修饰。
 * 因为无法执行这个抽象方法，因此这个类也必须申明为抽象类(abstract class)
 * 用abstract修饰的类就是抽象类，我们无法实例化一个抽象类，只能通过其子类来进行实例化。
 * <p>
 * 抽象类本身设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则会编译报错。
 * 因此，抽象方法实际上相当于定义了"规范"。
 * <p>
 * 面向抽象编程
 * 抽象类在进行方法调用时，不关心类型变量的具体子类型，这种尽量引用高层次类型，避免引用实际子类型的方式。
 * 本质：上层代码之定义规范(例如：abstract class Person)
 * 不需要子类就可以实现业务逻辑(正常编译)
 * 具体的业务逻辑由不同的子类实现，调用者并不关心。
 */

/**
 * 动物
 * 抽象类
 * 抽象类可以有静态方法
 * 抽象类不能被实例化，但是其子类可以实例化。
 * 子类继承抽象父类后，需要重写父类的抽象方法。但是仍然存在未实现抽象方法，那其子类还是一个抽象类
 */
// 如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用abstract修饰。
// 因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。
// 使用abstract修饰的类就是抽象类。我们无法实例化一个抽象类
// 抽象类，不能实例化
// 多态：允许添加更多类型的子类实现功能扩展，不需修改基于父类的代码。
abstract class Animal {

    //可以有构造函数
    public Animal() {
    }

    // 可以有普通方法
    public void eat() {
        System.out.println("动物吃了");
    }

    /*
     * abstract不可以与以下关键字同在
     * final ：抽象类需要集成，final修饰的无法集成
     * static ：抽象类抽象方法无方法体，调用无意义
     * private：抽象类的方法需要被覆盖，如果private修饰的话，子类无法访问
     */
    // 没有方法体的抽象方法，需要子类重写
    public abstract void sleep();

    // 如果父类或基类的run()没有实际意义，方法体是否可以去除
    // 答案是不行，编译错误，因为定义方法的时候，必须实现方法的语句。
    // 又不能删除父类的run()方法，删除就失去了多态的特性。
    /*public void run() {
        System.out.println("Animal.run");
    }*/
    // public void run(); // compile error
    // 如果父类的方法本身不需要实现任何功能，只是为了方法定义，目的是让子类去覆写，可以将父类的方法改为抽象方法。
    // 这样还是编译有错，因为方法是抽象的,本身没有任何方法语句，无法执行，本类也无法实例化，
    // 所以把本类也声明为抽象类。
    public abstract void run();

    // 静态方法
    public static void method() {
        System.out.println("abstract class Animal static method");
    }
}

// 实例子类猫
class Cat extends Animal {

    // 所有的抽象方法必须子类来覆写
    @Override
    public void sleep() {
        System.out.println("猫，睡了!");
    }

    @Override
    public void run() {
        System.out.println("猫，跑了!");
    }

    @Override
    public void eat() {
        System.out.println("猫，吃了!");
    }
}

// 实例子类狗
class Dog extends Animal {

    @Override
    public void sleep() {
        System.out.println("狗，睡了!");
    }

    @Override
    public void run() {
        System.out.println("狗，跑了!");
    }
}