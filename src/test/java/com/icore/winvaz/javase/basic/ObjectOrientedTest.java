package com.icore.winvaz.javase.basic;

import com.icore.winvaz.javase.Person;
import org.junit.jupiter.api.Test;

/**
 * 面向对象：
 * 定义：
 * 面向对象是相对于面向过程而言，是一种思想。
 * <p>
 * 强调：
 * 将功能封装进对象，强调具备了功能的对象。
 * 不关注过程
 * <p>
 * 面向过程：
 * 强调的是功能行为，关注完成的过程
 * <p>
 * 面向对象是基于面向过程的！
 * <p>
 * 例子：
 * 孙悟空三打白骨精
 * 面向过程：
 * 师傅召唤孙悟空
 * 第一次：孙悟空踹脸，白骨精跑了
 * 第二次：孙悟空露脸了，白骨精留下一句，长得太丑。吓跑了。
 * 第三次：孙悟空，老孙不玩了，直接如意金箍棒，一棒毙命。于是得到了  吹博kill
 * 面向对象：
 * 师傅召唤孙悟空，调用孙悟空的三打白骨精的方法
 * <p>
 * 在三打白骨精之后，师傅赶走了悟空。
 * 师傅又遇到困难了：
 * 面向过程：
 * 召唤八戒
 * 八戒去打妖精：我回高老庄了！
 * 召唤悟净
 * 悟净来一句：大师兄不好了，师傅被妖怪抓走了！
 * 师傅就被抓了
 * 悟净请大师兄
 * 大师兄：
 * 找妖怪
 * 遇到困难
 * 找高人相助
 * 就出师傅
 * 妖怪毙命
 * <p>
 * 面向对象：
 * 召唤八戒和悟净，调用其找悟空的方法
 * 调用悟空的打妖怪的方法
 * <p>
 * 利用面向对象的思维对比面向过程的思维来处理以下案例：
 * 1、买电脑
 * <p>
 * 2、吃烤鸭
 * 面向过程：
 * 买一对小鸭子
 * 养鸭子
 * 养大之后大鸭子下小鸭子，当满足鸭子可以自然繁殖时
 * 宰鸭子（大鸭子）：杀鸭子，开水拔毛，开膛破肚，整理鸭杂
 * 上网学习如果做烤鸭
 * 买作料，食材，工具
 * 开始做鸭子
 * 。。。
 * 在做好鸭子后，饱含泪水，终于吃上了烤鸭
 * 面向对象：
 * 调用全聚德的为我提供烤鸭的方法，大吃一顿，给全聚德传递一个参数(money!)
 * 注意：
 * 全聚德用什么鸭子？不知道  属性
 * 全聚德怎么做鸭子？不知道  方法
 * <p>
 * <p>
 * <p>
 * 经典案例：
 * 将大象放进冰箱：
 * 如果使用面向过程的思想：
 * 打开冰箱
 * 把大象放进去
 * 关上冰箱
 * <p>
 * //又来了一只骆驼，骆驼也想进冰箱
 * 我需要修改所有的代码：
 * 打开冰箱
 * 把骆驼放进去
 * 关上冰箱
 * <p>
 * 面向对象：
 * 冰箱.打开()
 * 大象.进去()//骆驼.进去()
 * 冰箱.关闭()
 * <p>
 * class 冰箱:
 * public void 打开的方法(){
 * }
 * public void 关闭的方法(){
 * }
 * class 大象：a
 * public void 进去(){
 * }
 * class 骆驼：
 * public void 进去(){
 * }
 * //又来了一只骆驼，骆驼也想进冰箱
 * 只需要修改部分代码
 */
public class ObjectOrientedTest {
    /**
     * 将现实事物抽象成类
     * 将人这种现实事物抽象成Person类
     * <p>
     * 类的注意事项：
     * 类中属性叫做成员变量
     * 类中功能叫做成员函数（成员方法）
     * 成员函数与成员方法均叫做类的成员
     * <p>
     * 成员变量是直接定义在类中的，与成员函数是平等的关系
     * 目前为止，成员函数的修饰符不再强制要求使用static：之前是因为使用main方法直接调用其他方法，静态方法
     * 不能直接调用非静态方法。
     * 之后我们通常是创建类的实例，使用实例来调用其方法。这样不是直接调用就可以调用非静态方法.
     * <p>
     * 访问对象的属性：对象名.属性名   叫做：该对象的XX属性
     * 调用对象的方法：对象名.方法或者对象名.方法名()
     */
    /**
     * 在一个文件当中可以定义多个类，并且在编译时，多个类都以独立的字节码文件存在。当互相使用时，
     * 只要在同一文件夹下，即可以访问到(前提为默认修饰权限)
     * <p>
     * 在一个文件中，与文件名相同的类中，需要有main方法，用来供JVM调用。这个类为这个文件的主类。
     */
    /**
     * 成员变量与局部变量的区别：
     * <p>
     * 成员变量：
     * 成员变量定义在类中，在整个类中都可以被访问。
     * 成员变量随着对象的建立而建立，存在于对象所在的堆内存中。
     * 成员变量有默认初始化值。
     * 局部变量：
     * 局部变量只定义在局部范围内，如：函数内，语句内等。
     * 局部变量存在于栈内存中。
     * 作用的范围结束，变量空间会自动释放。
     * 局部变量没有默认初始化值。
     * <p>
     * 在变量的访问过程当中，符合就近原则。
     */
    @Test
    public void test() {
        Person person = new Person();
        person.eat();
        /*
        System.out.println(person.name); // null 引用类型的默认值为null
        System.out.println(person.age); // null
        System.out.println(person.sex); // 0 基本数据类型的默认值为0
        */
    }

    /**
     * 匿名对象：
     * 匿名的是实例对象，而不是类。
     * 指没有名字的对象。
     * <p>
     * 匿名对象的使用：
     * 1、单独使用:均为一次调用(或者链式调用)
     * 2、作为参数：匿名对象必须对相应的属性含有可使用的值
     * 对于属性的初始化，通常是在创建对象的时候，直接赋值
     */
    @Test
    public void test1() {
        new Person().eat();
    }

    /**
     * 封装(encapsulation)是一种对象功能内聚的表现形式，使模块之间耦合度更低，更具有维护性。
     * 封装是在抽象的基础上决定信息是否公开，以及公开等级，核心问题是以什么样的方式暴露哪些信息
     * 封装的具体要求符合设计模式七大原则之一的迪米特法则。即A模块使用B模块的某个接口，对B模块中除此行为之外的其他信息知道得尽可能少。
     * 封装这件事是由俭入奢易，由奢入俭难。
     * 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。
     * 好处：
     * 将变化隔离
     * 便于使用
     * 提高重用性
     * 提高安全性
     * 封装原则：
     * 将不需要对外提供的内容都隐藏起来。
     * 把属性都隐藏，提供公共方法对其访问。
     * 关键字：
     * private：私有：只有在对象内部才可以调用
     * <p>
     * 在封装过程中：
     * 通常将赋值与获取值的方法娶成"固定"：get获取/set设置
     * 原因：
     * 1.符合起名时的见名知意
     * 2.在后期，尤其是就业班很多的框架当中(尤其是持久层)，是对属性的get/set方法进行字符串的拼接及查找动作。
     * 所以必须设置成get/set方法，否则该框架无法使用。
     * 注意：
     * 将属性使用private修饰符修饰，不是唯一的一种封装方法，只是其中的一种。
     */
    /**
     * t特点：this代表其所在函数所属对象的引用。
     * 换言之：
     * 	this代本类对象的引用。
     * 	没有对象实例，this就没有意义。
     * 什么时候使用this关键字呢？
     * 当在函数内需要用到调用该函数的对象时，就用this。
     * 局部变量隐藏成员变量（重名）
     * 构造函数中用(第一条语句上)
     */
    @Test
    public void test2() {
        // person就是this  this代表person
        Person person = new Person();

        // 属性改为私有之后，对象不能直接访问, 通过get/set来访问
        /*
        person.name = "张三";
        person.age = 12;
        person.sex = 1;
        person.loveCode = false;

        System.out.println(person.name); // null
        System.out.println(person.age); // null
        System.out.println(person.sex); // 0
        System.out.println(person.loveCode); // false

        person.eat();

        Person person1 = new Person();
        person1.name = "李四";
        person1.age = 13;
        person1.sex = 1;
        person1.loveCode = true;

        // 某人与某人发生冲突
        person1.age = 2;
        person1.loveCode = false;

        System.out.println(person.name); // null
        System.out.println(person.age); // null
        System.out.println(person.sex); // 0
        System.out.println(person.loveCode);

        person1.eat();
        */
        person.setName("张三");
        person.setAge(10);
        System.out.println(person.getName());
        System.out.println(person.getAge());
    }
}

