day24
1.	什么是进程：
  正在运行的程序所占有的内存的空间，叫做进程。
  内存360safe.exe，占有内存的空间，进程。木马，修复，体检，是整个360safe进程中的一个子程序
2.	什么是线程：
  一个应用程序中的子程序，对于CPU，子程序可以有一条独立的执行路径，称为线程。
  特点：依靠一个应用程序，对于其他子程序，独立被CPU执行的
3.	多线程技术好处
   充分利用CPU的资源，程序的同时运行，提高效率
4.	Java程序中的线程创建
  利用操作系统，我们不能直接在系统上创建并运行线程，必须依靠JVM，帮助我们完成这个功能。万物都是对象，线程这个事物也是对象，java.lang.Thread
  创建线程的第一种方法
	定义类继承Thread  class extends Thread
	重写Thread类的run方法   public void run
	创建Thread类的子类对象
	调用子类对象中的start()方法，开启线程
	start()做了两件事，告诉JVM开启一个对CPU的执行路径，调用run方法

5.	获取和设置线程的名字
   既然获取线程的名字，找描述线程对象的类Thread，提供获取名子的方法
   Thread类的方法 String getName()获取线程的名字
   获取到运行main方法的线程的名字，main方法运行也是由线程来执行的，如果我们可以获取到执行main方法的线程对象 Thread类中，静态方法：
   static Thread currentThread()返回当前正在执行的线程对象，适合于不是Thread子类中获取线程名字
   Thread类的方法  void setName(字符串的名字)设置线程名字
   利用Thread类的构造方法，传递字符串的名字  Thread(字符串名字)

6.	线程的状态图
  掌握线程的每一个状态，图必须会画

7.	通过案例，引出多线的数据安全隐患，和创建线程的第二种方式
  火车票，一列火车  100个票，网络，电话，车站，代售点--线程
  多线程并发操作车票
  多线程操作同一个数据，有安全隐患，必须考虑安全问题
  解决线程操作同一个数据的安全问题，如果一个线程休眠了，其他线程不能执行，同一个时间内，操作数据的线程，只能有一个，保证数据的安全了
引出创建线程的第二种方式
	定义类，实现Runnable接口
	重写run方法
	创建Thread类对象 new Thread()构造方法中，传递Runnable接口的实现类对象
	调用Thread对象方法start()，开启线程
  两种创建方式的区别：第一种继承，单继承局限性，数据是线程的独有数据
   第二种创建方式，实现接口方式，避免了单继承的局限性，同时线程的数据共享
8.	同步机制，保证多线程在操作共享数据的安全性
    同步代码块:
        格式:  synchronized(对象){
              线程操作的共享数据
         }
 对象：专业名词，对象监视器，锁
 同步代码块，作用分配锁，线程进入同步代码块后，会把锁给线程，持有锁的线程，当线程执行完毕后，出去同步代码块，锁还给同步代码块，
 一但线程持有了锁，肯定进入了同步代码块，没有锁的线程进不来
  同步的原理，上厕所的原理，人排队，就是线程，厕所里面的门锁，只能被一个人持有，不出来别人进去，原理保证了多线程操作共享数据时候的安全性。
  但是加上同步以后，程序的运行速度，有所减慢，线程安全了，执行效率降低了，在安全和效率的问题上，只能选择牺牲效率了

9.	模拟银行的存钱
  模拟储户去多个窗口，存储钱，两个窗口，每个窗口存储3次，每次存100元。
  银行是对象，存钱功能不是储户是银行，储户调用银行的存钱方法，钱传递
  方法add()存钱的，里面所有的代码，都是线程操作的共享数据，不采用同步代码块的方式，因为方法中的所有都是线程共享，同步整个方法
  同步方法有锁吗，写同步代码块的时候，自己定义的对象，当作了同步中的锁，对象监视器，锁肯定有，而且锁必须是对象，同步方法的锁就是this,表示本类对象引用.
  静态方法，同步修饰，静态方法中的同步的锁是谁，锁必须是对象。
  Bank.class文件，字节码文件，进内存，Java中，一切都是对象，这个文件也是一个对象，静态方法的同步锁，是自己类class文件这个对象，如何获取class文件这个对象
每一种数据类型，JVM都赋予他一个静态成员变量，变量的返回值就是本类的class文件对象。  静态方法的同步锁是 本类.class 属性返回的字节码文件的对象

10.	多线程并发的单例模式懒汉
   懒汉，延迟加载，多线程并发实验，单例模式能否保证对象的唯一性
   面试的时候，写同步代码块，不要写同步方法，进行两次判断提高程序的效率

11.	死锁
  多线程在争抢同一把锁的时候，造成的程序的假死现象。实际的开发中不可能出现，面试中，同步是否理解。很重要的案例，面试过关

12.	线程通信
  多线程操作同一个资源，一个赋值一个取值，数据的错乱，使用同步技术，发现数据安全问题，还是没解决
	同步中的程序都是线程的共享数据吗
	同步中的锁是同一个吗
     使用的是线程的等待与唤醒机制，实现输入输出的间隔效果，复杂在于解决思想
   等待与唤醒的方法  Object类的方法 wait  notify 程序出现了异常
     java.lang.IllegalMonitorStateException
     导致异常的原因，wait()  notify()导致的异常，使用等待与唤醒，必须有锁的支持，wait，notify必须写在同步中，必须用锁对象调用

